#!/usr/bin/env python3
"""
DoorLREngine: FSM engine that uses DirectionClassifier for door left/right logic.
"""
from __future__ import annotations

from typing import Optional, Tuple, Any, Dict
from datetime import datetime, timezone

from .fsm_engine import IFSMEngine
from .database_models import DatabaseManager, DetectionState, BoatStatus
from .logging_config import get_logger
from .direction_classifier import DirectionClassifier, LRParams
from .rf_signal_filter import PerScannerRFFilter, load_calibration_bias, apply_bias_compensation


logger = get_logger()


class DoorLREngine(IFSMEngine):
    def __init__(self, db_manager: DatabaseManager, outer_scanner_id: str, inner_scanner_id: str,
                 rssi_threshold: int = -80, hysteresis: int = 10, **kwargs):
        self.db = db_manager
        self.outer_scanner_id = (outer_scanner_id or '').lower()
        self.inner_scanner_id = (inner_scanner_id or '').lower()
        self.rssi_threshold = rssi_threshold
        self.hysteresis = hysteresis

        # Initialize RF signal filtering for noise reduction
        self.rf_filter = PerScannerRFFilter(alpha=0.3, window_size=5)
        
        # Load calibration bias if available
        self.bias_map = load_calibration_bias()
        if self.bias_map:
            logger.info(f"Loaded RSSI bias compensation: {self.bias_map}", "DOOR_LR")
        else:
            logger.info("No calibration bias found, using raw RSSI values", "DOOR_LR")

        # Robust parameters for real-world deployment
        params = LRParams(
            active_dbm=-75,  # More realistic threshold for metal environment
            energy_dbm=-70,  # Higher energy threshold for reliable detection
            delta_db=5.0,    # Larger difference required for clear direction
            dwell_s=0.5,     # Longer dwell time for stability
            window_s=2.0,    # Longer window for better analysis
            tau_min_s=0.2,   # Longer tau for reliable timing
            cooldown_s=3.0,   # Longer cooldown to prevent false triggers
            slope_min_db_per_s=5.0,  # Higher slope requirement for clear movement
            min_peak_sep_s=0.5,     # Reasonable peak separation time
        )
        calib_map = {"lag_positive": "LEAVE", "lag_negative": "ENTER"}
        self.classifier = DirectionClassifier(params, calib_map, logger)

    def process_detection(self, scanner_id: str, beacon_id: str, rssi: int) -> Optional[Tuple[Any, Any]]:
        try:
            sid = (scanner_id or '').lower()
            leftish = sid.endswith('left') or sid.endswith('door-left') or sid.endswith('gate-left')
            rightish = sid.endswith('right') or sid.endswith('door-right') or sid.endswith('gate-right')
            if not (leftish or rightish):
                # Fallback mapping based on inner/outer: treat inner as left, outer as right for door-LR
                leftish = sid == self.inner_scanner_id
                rightish = sid == self.outer_scanner_id

            # Determine logical scanner name
            logical_scanner = f"gate-left" if leftish else ("gate-right" if rightish else sid)
            
            # Step 1: Apply bias compensation from calibration
            rssi_with_bias = apply_bias_compensation(logical_scanner, float(rssi), self.bias_map)
            
            # Step 2: Apply RF signal filtering to reduce noise
            rssi_filtered = self.rf_filter.update(logical_scanner, rssi_with_bias)
            
            # Log the processing chain for debugging
            logger.debug(
                f"RSSI Processing - Raw: {rssi} dBm → Bias: {rssi_with_bias:.1f} dBm → Filtered: {rssi_filtered:.1f} dBm",
                "DOOR_LR"
            )
            
            # Provide a monotonic-like timestamp (seconds)
            t = datetime.now(timezone.utc).timestamp()

            # Use filtered RSSI for direction classification
            events = self.classifier.update(beacon_id, logical_scanner, rssi_filtered, t)
            logger.debug(f"DoorLREngine: scanner={scanner_id}, beacon={beacon_id}, rssi={rssi}, events={len(events)}")
            
            if not events:
                logger.debug(f"  No events generated by classifier")
                return None

            # Commit first event as state change for compatibility
            ev = events[0]
            logger.info(f"DoorLREngine received event: {ev.direction} for {beacon_id}")
            
            old_state = self.db.get_beacon_state(beacon_id)
            now = datetime.now(timezone.utc)
            
            if ev.direction == 'ENTER':
                new_state = DetectionState.INSIDE
                # Save entry timestamp
                self.db.update_beacon_state(
                    beacon_id=beacon_id,
                    state=new_state,
                    entry_timestamp=now
                )
                # Update boat status to IN_HARBOR and log trip end
                try:
                    with self.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute("SELECT boat_id FROM boat_beacon_assignments WHERE beacon_id = ?", (beacon_id,))
                        row = cursor.fetchone()
                        if row:
                            boat_id = row[0]
                            self.db.update_boat_status(boat_id, BoatStatus.IN_HARBOR)
                            trip_id, duration = self.db.end_trip(boat_id, beacon_id, now)
                            if trip_id:
                                logger.info(f"Trip completed for boat {boat_id}: {duration} min", "TRIP")
                except Exception as e:
                    logger.error(f"Failed to end trip: {e}", "TRIP")
            else:
                new_state = DetectionState.OUTSIDE
                # Save exit timestamp
                self.db.update_beacon_state(
                    beacon_id=beacon_id,
                    state=new_state,
                    exit_timestamp=now
                )
                # Update boat status to OUT and log trip start
                try:
                    with self.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute("SELECT boat_id FROM boat_beacon_assignments WHERE beacon_id = ?", (beacon_id,))
                        row = cursor.fetchone()
                        if row:
                            boat_id = row[0]
                            self.db.update_boat_status(boat_id, BoatStatus.OUT)
                            trip_id = self.db.start_trip(boat_id, beacon_id, now)
                            logger.info(f"Trip started for boat {boat_id}: {trip_id}", "TRIP")
                except Exception as e:
                    logger.error(f"Failed to start trip: {e}", "TRIP")
            
            return (new_state, new_state)  # keep signature compatible; UI uses .value
            
        except Exception as e:
            logger.error(f"Error processing detection for {beacon_id} from {scanner_id}: {e}", "DOOR_LR")
            # Return None to indicate no state change, preventing system crash
            return None

    def get_beacon_state(self, beacon_id: str):
        return self.db.get_beacon_state(beacon_id)


