#!/usr/bin/env python3
"""
DoorLREngine: FSM engine that uses DirectionClassifier for door left/right logic.
"""
from __future__ import annotations

from typing import Optional, Tuple, Any, Dict
from datetime import datetime, timezone

from .fsm_engine import IFSMEngine
from .database_models import DatabaseManager, DetectionState, BoatStatus
from .logging_config import get_logger
from .direction_classifier import DirectionClassifier, LRParams


logger = get_logger()


class DoorLREngine(IFSMEngine):
    def __init__(self, db_manager: DatabaseManager, outer_scanner_id: str, inner_scanner_id: str,
                 rssi_threshold: int = -80, hysteresis: int = 10, **kwargs):
        self.db = db_manager
        self.outer_scanner_id = (outer_scanner_id or '').lower()
        self.inner_scanner_id = (inner_scanner_id or '').lower()
        self.rssi_threshold = rssi_threshold
        self.hysteresis = hysteresis

        # Make parameters much more sensitive for testing
        params = LRParams(
            active_dbm=-90,  # Much more sensitive threshold
            energy_dbm=-85,  # Lower energy threshold
            delta_db=2.0,    # Smaller difference required
            dwell_s=0.05,    # Shorter dwell time
            window_s=0.5,    # Shorter window
            tau_min_s=0.05,  # Shorter tau
            cooldown_s=1.0,   # Shorter cooldown
            slope_min_db_per_s=2.0,  # Smaller slope requirement
            min_peak_sep_s=0.05,     # Much shorter peak separation
        )
        calib_map = {"lag_positive": "LEAVE", "lag_negative": "ENTER"}
        self.classifier = DirectionClassifier(params, calib_map, logger)

    def process_detection(self, scanner_id: str, beacon_id: str, rssi: int) -> Optional[Tuple[Any, Any]]:
        # Map scanner IDs to left/right by suffix
        sid = (scanner_id or '').lower()
        leftish = sid.endswith('left') or sid.endswith('door-left') or sid.endswith('gate-left')
        rightish = sid.endswith('right') or sid.endswith('door-right') or sid.endswith('gate-right')
        if not (leftish or rightish):
            # Fallback mapping based on inner/outer: treat inner as left, outer as right for door-LR
            leftish = sid == self.inner_scanner_id
            rightish = sid == self.outer_scanner_id

        # Provide a monotonic-like timestamp (seconds)
        t = datetime.now(timezone.utc).timestamp()
        logical_scanner = f"gate-left" if leftish else ("gate-right" if rightish else sid)

        events = self.classifier.update(beacon_id, logical_scanner, float(rssi), t)
        logger.debug(f"DoorLREngine: scanner={scanner_id}, beacon={beacon_id}, rssi={rssi}, events={len(events)}")
        
        if not events:
            logger.debug(f"  No events generated by classifier")
            return None

        # Commit first event as state change for compatibility
        ev = events[0]
        logger.info(f"DoorLREngine received event: {ev.direction} for {beacon_id}")
        
        old_state = self.db.get_beacon_state(beacon_id)
        now = datetime.now(timezone.utc)
        
        if ev.direction == 'ENTER':
            new_state = DetectionState.INSIDE
            # Save entry timestamp
            self.db.update_beacon_state(
                beacon_id=beacon_id,
                state=new_state,
                entry_timestamp=now
            )
            # Update boat status to IN_HARBOR and log trip end
            try:
                with self.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute("SELECT boat_id FROM boat_beacon_assignments WHERE beacon_id = ?", (beacon_id,))
                    row = cursor.fetchone()
                    if row:
                        boat_id = row[0]
                        self.db.update_boat_status(boat_id, BoatStatus.IN_HARBOR)
                        trip_id, duration = self.db.end_trip(boat_id, beacon_id, now)
                        if trip_id:
                            logger.info(f"Trip completed for boat {boat_id}: {duration} min", "TRIP")
            except Exception as e:
                logger.error(f"Failed to end trip: {e}", "TRIP")
        else:
            new_state = DetectionState.OUTSIDE
            # Save exit timestamp
            self.db.update_beacon_state(
                beacon_id=beacon_id,
                state=new_state,
                exit_timestamp=now
            )
            # Update boat status to OUT and log trip start
            try:
                with self.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute("SELECT boat_id FROM boat_beacon_assignments WHERE beacon_id = ?", (beacon_id,))
                    row = cursor.fetchone()
                    if row:
                        boat_id = row[0]
                        self.db.update_boat_status(boat_id, BoatStatus.OUT)
                        trip_id = self.db.start_trip(boat_id, beacon_id, now)
                        logger.info(f"Trip started for boat {boat_id}: {trip_id}", "TRIP")
            except Exception as e:
                logger.error(f"Failed to start trip: {e}", "TRIP")
        
        return (new_state, new_state)  # keep signature compatible; UI uses .value

    def get_beacon_state(self, beacon_id: str):
        return self.db.get_beacon_state(beacon_id)


